<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>关于版本问题</title>
      <link href="/2025/07/20/2025-07-11-%E5%85%B3%E4%BA%8E%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
      <url>/2025/07/20/2025-07-11-%E5%85%B3%E4%BA%8E%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h3 id="准备版本升级公告"><a href="#准备版本升级公告" class="headerlink" title="准备版本升级公告"></a>准备版本升级公告</h3><ul><li>为了兼容 win11 的开发环境，准备升级 hexo 和 butterfly 到最新版本</li><li>以及站内图片太多,要减小体积,以更快的加载,要找一个图床储存</li><li>可能会更新的慢一些,莫急~</li></ul>]]></content>
      
      
      <categories>
          
          <category> 要升级版本了 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2K4K8K壁纸随意下载！</title>
      <link href="/2025/07/20/2025-07-20-%E8%B6%85%E6%B8%85%E7%94%B5%E8%84%91%E5%A3%81%E7%BA%B8/"/>
      <url>/2025/07/20/2025-07-20-%E8%B6%85%E6%B8%85%E7%94%B5%E8%84%91%E5%A3%81%E7%BA%B8/</url>
      
        <content type="html"><![CDATA[<h3 id="网站介绍"><a href="#网站介绍" class="headerlink" title="网站介绍"></a>网站介绍</h3><ul><li>我想把收藏已久的 5 个免费超高清桌面壁纸下载网站推荐给大家，这些网站的壁纸资源极为丰富，涵盖了动漫、美丽风景、游戏等多种类型，2K、4K、8K 壁纸都可以随意下载！</li></ul><h3 id="Wallpaperscraft"><a href="#Wallpaperscraft" class="headerlink" title="Wallpaperscraft"></a>Wallpaperscraft</h3><ul><li><a href="https://wallpaperscraft.com/">链接（点击进入）</a></li><li>这是一个免费的壁纸网站，壁纸被详细分类，用户只需点击相应分类即可浏览，如动漫、游戏、美女、风景等。此外，右侧提供了按分辨率筛选的功能，壁纸也有评分系统。</li></ul><p><img src="/img/wzbj.png"></p><h3 id="壁纸深渊"><a href="#壁纸深渊" class="headerlink" title="壁纸深渊"></a>壁纸深渊</h3><ul><li><a href="https://wall.alphacoders.com/?lang=Chinese">链接（点击进入）</a></li><li>这是一个提供高清壁纸免费下载的网站，拥有超过 100 万张壁纸，种类繁多且分类清晰。用户可以通过点击分类快速找到所需壁纸，还能按 4K、5K、8K 的标准进行筛选。除了单张壁纸外，这里还有多种壁纸合集可供浏览。</li></ul><h3 id="Wallhaven"><a href="#Wallhaven" class="headerlink" title="Wallhaven"></a>Wallhaven</h3><ul><li><a href="https://wallhaven.cc/">链接（点击进入）</a></li><li>一个提供高质量超清壁纸下载的网站，拥有超过 100 万张优质壁纸，涵盖了美女、风景、动漫、游戏等多种类型。用户可以直接进行搜索，也能浏览热门标签或排行榜，网站还设有 4K 标签供直接查看。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 快来下载使用吧~ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 超清壁纸 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>16种MBTI人格测试</title>
      <link href="/2025/07/18/2025-07-18-MBTI%E6%B5%8B%E8%AF%95/"/>
      <url>/2025/07/18/2025-07-18-MBTI%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h3 id="16-种人格测试"><a href="#16-种人格测试" class="headerlink" title="16 种人格测试"></a>16 种人格测试</h3><ul><li><a href="https://www.16personalities.com/ch/">中文版测试入口（点击测试）</a></li><li>测完返回看结果哦~</li></ul><h3 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h3><ul><li>迈尔斯-布里格斯类型指标（Myers–Briggs Type Indicator，MBTI）是由美国作家伊莎贝尔·布里格斯·迈尔斯和她的母亲凯瑟琳·库克·布里格斯共同制定的一种人格类型理论模型。<br><img src="/img/rgcs1.png"></li><li>每个维度各有两种不同的偏好倾向，分别是外向 (E) 、内向 (I) 、感觉 (S) &#x2F;直觉 (N) 、情感 (F) &#x2F;思考 (T)判断 (J) &#x2F;感知 (P) 。8 种偏好倾向，组合产生 16 种不同的人格类型。</li></ul><h3 id="16-种-MBTI-性格类型的主要特征："><a href="#16-种-MBTI-性格类型的主要特征：" class="headerlink" title="16 种 MBTI 性格类型的主要特征："></a>16 种 MBTI 性格类型的主要特征：</h3><p>(1) ISTJ</p><ul><li>安静、严肃，通过全面性和可靠性获得成功。实际，有责任感。决定有逻辑性，并一步步地朝着目标前进，不易分心。喜欢将工作、家庭和生活都安排得井井有条。重视传统和忠诚。<br>(2) ISFJ</li><li>安静、友好、有责任感和良知。坚定地致力于完成他们的义务。全面、勤勉、精确，忠诚、体贴，留心和记得他们重视的人的小细节，关心他人的感受。努力把工作和家庭环境营造得有序而温馨。<br>(3) INFJ</li><li>寻求思想、关系、物质等之间的意义和联系。希望了解什么能够激励人，对人有很强的洞察力。有责任心，坚持自己的价值观。对于怎样更好的服务大众有清晰的远景。在对于目标的实现过程中有计划而且果断坚定。<br>(4) INFP</li><li>理想主义，对于自己的价值观和自己觉得重要的人非常忠诚。希望外部的生活和自己内心的价值观是统一的。好奇心重，很快能看到事情的可能性，能成为实现想法的催化剂。寻求理解别人和帮助他们实现潜能。适应力强，灵活，善于接受，除非是有悖于自己的价值观的。<br><img src="/img/rgcs2.jpg"><br>(5) INTJ</li><li>在实现自己的想法和达成自己的目标时有创新的想法和非凡的动力。能很快洞察到外界事物间的规律并形成长期的远景计划。一旦决定做一件事就会开始规划并直到完成为止。多疑、独立，对于自己和他人能力和表现的要求都非常高。<br>(6) INTP</li><li>对于自己感兴趣的任何事物都寻求找到合理的解释。喜欢理论性的和抽象的事物，热衷于思考而非社交活动。安静、内向、灵活、适应力强。对于自己感兴趣的领域有超凡的集中精力深度解决问题的能力。多疑，有时会有点挑剔，喜欢分析。<br>(7) ISTP</li><li>灵活、忍耐力强，是个安静的观察者直到有问题发生，就会马上行动，找到实用的解决方法。分析事物运作的原理，能从大量的信息中很快的找到关键的症结所在。对于原因和结果感兴趣，用逻辑的方式处理问题，重视效率。<br>(8) ISFP</li><li>安静、友好、敏感、和善。享受当前。喜欢有自己的空间，喜欢能按照自己的时间表工作。对于自己的价值观和自己觉得重要的人非常忠诚，有责任心。不喜欢争论和冲突。不会将自己的观念和价值观强加到别人身上。<br><img src="/img/rgcs3_r.jpg"><br>(9) ESTP</li><li>灵活、忍耐力强，实际，注重结果。觉得理论和抽象的解释非常无趣。喜欢积极地采取行动解决问题。注重当前，自然不做作，享受和他人在一起的时刻。喜欢物质享受和时尚。学习新事物最有效的方式是通过亲身感受和练习。<br>(10) ESFP</li><li>外向、友好、接受力强。热爱生活、人类和物质上的享受。喜欢和别人一起将事情做成功。在工作中讲究常识和实用性，并使工作显得有趣。灵活、自然不做作，对于新的任何事物都能很快地适应。学习新事物最有效的方式是和他人一起尝试。<br>(11) ENFJ</li><li>热情、为他人着想、易感应、有责任心。非常注重他人的感情、需求和动机。善于发现他人的潜能，并希望能帮助他们实现。能成为个人或群体成长和进步的催化剂。忠诚，对于赞扬和批评都会积极地回应。友善、好社交。在团体中能很好地帮助他人，并有鼓舞他人的领导能力。<br>(12) ENFP</li><li>热情洋溢、富有想象力。认为人生有很多的可能性。能很快地将事情和信息联系起来，然后很自信地根据自己的判断解决问题。总是需要得到别人的认可，也总是准备着给与他人赏识和帮助。灵活、自然不做作，有很强的即兴发挥的能力，言语流畅。<br><img src="/img/recs4_r.jpg"><br>(13) ESTJ</li><li>实际、现实主义。果断，一旦下决心就会马上行动。善于将项目和人组织起来将事情完成，并尽可能用最有效率的方法得到结果。注重日常的细节。有一套非常清晰的逻辑标准，有系统性地遵循，并希望他人也同样遵循。在实施计划时强而有力。<br>(14) ESFJ</li><li>热心肠、有责任心、合作。希望周边的环境温馨而和谐，并为此果断地执行。喜欢和他人一起精确并及时地完成任务。事无巨细都会保持忠诚。能体察到他人在日常生活中的所需并竭尽全力帮助。希望自己和自己的所为能受到他人的认可和赏识。<br>(15) ENTJ</li><li>坦诚、果断，有天生的领导能力。能很快看到公司&#x2F;组织程序和政策中的不合理性和低效能性，发展并实施有效和全面的系统来解决问题。善于做长期的计划和目标的设定。通常见多识广，博览群书，喜欢拓广自己的知识面并将此分享给他人。在陈述自己的想法时非常强而有力。<br>(16) ENTP</li><li>反应快、睿智，有激励别人的能力，警觉性强、直言不讳。在解决新的、具有挑战性的问题时机智而有策略。善于找出理论上的可能性，然后再用战略的眼光分析。善于理解别人。不喜欢例行公事，很少会用相同的方法做相同的事情，倾向于一个接一个的发展新的爱好。<br><img src="/img/rgcs5_r.jpg"></li></ul><h3 id="结尾："><a href="#结尾：" class="headerlink" title="结尾："></a>结尾：</h3><ul><li>MBTI 人格测试可以帮助个人更好地了解自己。通过参与测试，您可以对自己的个性特征有深入的了解。测试结果可以揭示一个人的偏好、沟通方式、决策方法和个人能力。这对个人的职业选择、人际交往和自我意识具有一定的价值。</li><li>MBTI 性格测试在职业规划领域也有广泛的应用。职业方向的选择和追求，是每个人成长过程中不可避免的问题，对于人生的发展具有非常关键的影响。而 MBTI 测试可以分析个人的性格类型、特点和需求，从而帮助个人建立与自己性格匹配的职业规划思路。</li></ul><h3 id="MBTI-测试仅是一个心理学领域的辅助工具，其结果仅供参考，不是全面评估个人能力和潜力的工具。我们更多可以结合自己过去的人生经历和体会去认识自我。这样的认识有助于我们更好地应对不同的情境和人际关系，提升自己的个人能力和职业发展。"><a href="#MBTI-测试仅是一个心理学领域的辅助工具，其结果仅供参考，不是全面评估个人能力和潜力的工具。我们更多可以结合自己过去的人生经历和体会去认识自我。这样的认识有助于我们更好地应对不同的情境和人际关系，提升自己的个人能力和职业发展。" class="headerlink" title="MBTI 测试仅是一个心理学领域的辅助工具，其结果仅供参考，不是全面评估个人能力和潜力的工具。我们更多可以结合自己过去的人生经历和体会去认识自我。这样的认识有助于我们更好地应对不同的情境和人际关系，提升自己的个人能力和职业发展。"></a>MBTI 测试仅是一个心理学领域的辅助工具，其结果仅供参考，不是全面评估个人能力和潜力的工具。我们更多可以结合自己过去的人生经历和体会去认识自我。这样的认识有助于我们更好地应对不同的情境和人际关系，提升自己的个人能力和职业发展。</h3>]]></content>
      
      
      <categories>
          
          <category> 快来测试一下吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MBTI </tag>
            
            <tag> 人格测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js-this作用</title>
      <link href="/2025/07/10/2025-06-23-%E5%85%B3%E4%BA%8E%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91js%E4%B8%AD%E7%9A%84this%E8%AF%A6%E7%BB%86%E7%94%A8%E6%B3%95/"/>
      <url>/2025/07/10/2025-06-23-%E5%85%B3%E4%BA%8E%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91js%E4%B8%AD%E7%9A%84this%E8%AF%A6%E7%BB%86%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><h3 id="this-的作用"><a href="#this-的作用" class="headerlink" title="this 的作用"></a>this 的作用</h3><ul><li>this 可以帮我们简化很多代码。比如<code>xiaoming.name</code>、<code>xiaoming.age</code>可以直接写成<code>this.name</code>、<code>this.age</code>。</li><li>特别是当我们不知道一个对象是什么，或者这个对象没有名字但又很想调用它的时候，就会使用到 this 对象。</li></ul><p><strong>举例：</strong></p><ul><li>遍历 DOM 对象，绑定 click 事件，调用当前点击的对象的 id，而不是所有对象的 id。</li></ul><p>代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span></span></span><br><span class="line"><span class="tag">    &lt;<span class="attr">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: green;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> myDiv = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;div&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; myDiv.<span class="property">length</span>; i++) &#123;</span></span><br><span class="line"><span class="language-javascript">            myDiv[i].<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">id</span>);</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div0&quot;</span>&gt;</span> div0<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div1&quot;</span>&gt;</span> div1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div2&quot;</span>&gt;</span> div2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div3&quot;</span>&gt;</span> div3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div4&quot;</span>&gt;</span> div4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>点击其中的任何一个元素后，<code>i</code>的打印结果是 5。你可能会觉得很惊讶。我们来解释一下：</p><p>当代码执行完毕后，i 已经等于 5 了。因为一旦运行程序，for 循环已经执行完了，此时 i 等于 5。</p><p>现在，我们尝试在 myDiv[i].onclick 事件中写代码，如果打印：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.<span class="built_in">log</span>(i);  <span class="comment">//打印结果为5</span></span><br></pre></td></tr></table></figure><p>如果打印：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.<span class="built_in">log</span>(myDiv[i].<span class="built_in">id</span>);</span><br></pre></td></tr></table></figure><p>上方这行代码，打印会报错，因为 i&#x3D;5；如果想打印每个 div 的 id，应该这样写：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.<span class="built_in">log</span>(this.<span class="built_in">id</span>);</span><br></pre></td></tr></table></figure><p>你看，this 的作用，就体现出来了。</p><p>PS：顺便提醒一下，上面的代码中，如果把<code>var i</code>改成<code>let i</code>，效果又完全不同了。参考链接：<a href="http://blog.csdn.net/stopllL/article/details/64130664">let 和 var 在 for 循环中的表现</a></p><h3 id="全局作用域中的-this"><a href="#全局作用域中的-this" class="headerlink" title="全局作用域中的 this"></a>全局作用域中的 this</h3><p>当一段代码在浏览器中执行时，所有的全局变量和对象都是在 window 对象上定义的。换而言之，所有的全局变量和对象都属于 window 对象。</p><h2 id="this-的定律"><a href="#this-的定律" class="headerlink" title="this 的定律"></a>this 的定律</h2><p>this 关键字永远指向函数（方法）运行时的<strong>所有者</strong>。</p><h3 id="函数赋值给变量时，this-指向-window"><a href="#函数赋值给变量时，this-指向-window" class="headerlink" title="函数赋值给变量时，this 指向 window"></a>函数赋值给变量时，this 指向 window</h3><p>比如：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var foo1 <span class="operator">=</span> args.getInfo<span class="comment">;</span></span><br><span class="line">foo1()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">var foo2 <span class="operator">=</span> function()&#123;&#125;<span class="comment">;</span></span><br><span class="line">foo2()<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>this 都是指向 window。</p><h3 id="以函数形式调用时，this-永远都是-window"><a href="#以函数形式调用时，this-永远都是-window" class="headerlink" title="以函数形式调用时，this 永远都是 window"></a>以函数形式调用时，this 永远都是 window</h3><h3 id="以方法的形式调用时，this-是调用方法的对象"><a href="#以方法的形式调用时，this-是调用方法的对象" class="headerlink" title="以方法的形式调用时，this 是调用方法的对象"></a>以方法的形式调用时，this 是调用方法的对象</h3><h2 id="解决闭包中的-this-指向问题"><a href="#解决闭包中的-this-指向问题" class="headerlink" title="解决闭包中的 this 指向问题"></a>解决闭包中的 this 指向问题</h2><p>内部函数是可以访问到外部函数的变量的。</p><p>方式一：直接通过父函数的名字访问</p><p>方式二：如果不知道父函数的名字，在父函数里加一句<code>_this = this</code>，此时<code>_this</code>相当于父函数的名字。</p><h3 id="当-this-遇到一些特殊的函数时"><a href="#当-this-遇到一些特殊的函数时" class="headerlink" title="当 this 遇到一些特殊的函数时"></a>当 this 遇到一些特殊的函数时</h3>]]></content>
      
      
      <categories>
          
          <category> js中的this用法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> this用法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js的同步任务和异步任务</title>
      <link href="/2025/07/01/2025-07-01-js%E7%9A%84%E5%90%8C%E6%AD%A5%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/"/>
      <url>/2025/07/01/2025-07-01-js%E7%9A%84%E5%90%8C%E6%AD%A5%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<hr><p>title: 01-单线程和异步<br>publish: true</p><hr><p><ArticleTopAd></ArticleTopAd></p><h2 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h2><p>JavaScript 语言和执行环境是<strong>单线程</strong>。即同一时间，只能处理一个任务。</p><p>具体来说，所谓单线程，是指 JS 引擎中负责解释和执行 JavaScript 代码的线程只有一个，也就是一次只能完成一项任务，这个任务执行完后才能执行下一个。所有的任务都<strong>需要排队</strong>。</p><p><strong>JS 为何要被设计为单线程呢</strong>？原因如下：</p><ul><li>首先是历史原因，在最初设计 JS 这门语言时，多进程、多线程的架构并不流行，硬件支持并不好。</li><li>其次是因为多线程的复杂性，多线程操作需要加锁，编码的复杂性会增高。</li><li>而且，如果多个线程同时操作同一个 DOM，在多线程不加锁的情况下，会产生冲突，最终会导致 DOM 渲染的结果不符预期。</li></ul><p>所以，为了避免这些复杂问题的出现，JS 被设计成了单线程语言。</p><h2 id="同步任务和异步任务"><a href="#同步任务和异步任务" class="headerlink" title="同步任务和异步任务"></a>同步任务和异步任务</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>如果当前正在执行的任务执行完成前，它就会<strong>阻塞</strong>其他正在排队的任务。为了解决这个问题，JS 在设计之初，将任务分成了两类：同步任务、异步任务。</p><ul><li>同步任务：在<strong>主线程</strong>上排队执行的任务。只有前一个任务执行完毕，才能执行下一个任务。</li><li>异步任务：不进入主线程、而是进入<strong>任务队列</strong>（Event Queue）的任务，该任务不会阻塞后面的任务执行。只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</li></ul><p>代码举例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;同步任务1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;异步任务&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;同步任务2&#x27;</span>)</span><br></pre></td></tr></table></figure><p>打印结果是：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">同步任务1</span><br><span class="line">同步任务2</span><br><span class="line">异步任务</span><br></pre></td></tr></table></figure><p>代码解释：第一行代码是同步任务，会<strong>立即执行</strong>；定时器里的回调函数是异步任务，需要等 1 秒后才会执行。假如定时器里的代码是同步任务，那需要等待 1 秒后，才能执行最后一行代码<code>console.log(&#39;同步任务2&#39;)</code>，也就是造成了主线程里的同步任务阻塞，这不是我们希望看到的。</p><p>比如说，网络图片的请求，就是一个异步任务。前端如果同时请求多张网络网络图片，谁先请求完成就让谁先显示出来。假如网络图片的请求做成同步任务，那就会出大问题，所有图片都得排队加载，如果第一张图片未加载完成，就得卡在那里，造成阻塞，导致其他图片都加载不出来。页面看上去也会很卡顿，这肯定是不能接受的。</p><h3 id="前端使用异步编程的场景"><a href="#前端使用异步编程的场景" class="headerlink" title="前端使用异步编程的场景"></a>前端使用异步编程的场景</h3><p>什么时候需要<strong>等待</strong>，就什么时候用异步。常见的异步场景如下：</p><ul><li>1、事件监听（比如说，按钮绑定点击事件之后，用户爱点不点。我们不可能卡在按钮那里，什么都不做。所以，应该用异步）</li><li>2、回调函数：<ul><li>2.1、定时器：setTimeout（定时炸弹）、setInterval（循环执行）</li><li>2.2、ajax 请求。</li><li>2.3、Node.js 中的一些方法回调。</li></ul></li><li>3、ES6 中的 Promise、Generator、async&#x2F;await</li></ul><p>现在的大部分软件项目，都是前后端分离的。后端生成接口，前端请求接口。前端发送 ajax 请求，向后端请求数据，然后<strong>等待一段时间</strong>后，才能拿到数据。这个请求过程就是异步任务。</p><h3 id="接口调用的方式"><a href="#接口调用的方式" class="headerlink" title="接口调用的方式"></a>接口调用的方式</h3><p>js 中常见的接口调用方式，有以下几种：</p><ul><li>原生 ajax、基于 jQuery 的 ajax</li><li>Promise</li><li>Fetch</li><li>axios</li></ul><p>下一篇文章，我们重点讲一下接口调用里的 Ajax，然后在 ES6 语法中学习 <strong>Promise</strong>。在这之前，我们需要先了解同步任务、异步任务的事件循环机制。</p><h3 id="事件循环机制（重要）"><a href="#事件循环机制（重要）" class="headerlink" title="事件循环机制（重要）"></a>事件循环机制（重要）</h3><p><img src="http://img.smyhvae.com/20210517_1431.png"></p><p>执行顺序如下：</p><ul><li>同步任务：进入主线程后，立即执行。</li><li>异步任务：会先进入 Event Table；等时间到了之后，再进入 Event Queue，然后排队（为什么要排队？因为同一时间，JS 只能执行一个任务）。比如说，<code>setTimeout(()=&gt; &#123;&#125;, 1000)</code>这种定时器任务，需要等一秒之后再进入 Event Queue。</li><li>当主线程的任务执行完毕之后，此时主线程处于空闲状态，于是会去读取 Event Queue 中的任务队列，如果有任务，则进入到主线程去执行。</li></ul><h3 id="多次异步调用的顺序"><a href="#多次异步调用的顺序" class="headerlink" title="多次异步调用的顺序"></a>多次异步调用的顺序</h3><ul><li>多次异步调用的结果，顺序可能不同步。</li><li>异步调用的结果如果<strong>存在依赖</strong>，则需要通过回调函数进行嵌套。</li></ul><h2 id="定时器：代码示例"><a href="#定时器：代码示例" class="headerlink" title="定时器：代码示例"></a>定时器：代码示例</h2><p>掌握了上面的事件循环原理之后，我们来看几个例子。</p><h3 id="举例-1"><a href="#举例-1" class="headerlink" title="举例 1"></a>举例 1</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>解释：先等同步任务执行完成后，再执行异步任务。</p><h3 id="举例-2（重要）"><a href="#举例-2（重要）" class="headerlink" title="举例 2（重要）"></a>举例 2（重要）</h3><p>如果我把上面的等待时间，从 1 秒改成 0 秒，你看看打印结果会是什么。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>可以看到，打印结果没有任何变化，这个题目在面试中经常出现，考的就是 <code>setTimeout(()=&gt; &#123;&#125;, 0)</code>会在什么时候执行。这就需要我们了解同步任务、异步任务的执行顺序，即前面讲到的<strong>事件循环机制</strong>。</p><p>解释：先等同步任务执行完成后，再执行异步任务。</p><p>同理，我们再来看看下面这段伪代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;异步任务&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"><span class="title function_">sleep</span>(<span class="number">5000</span>) <span class="comment">//表示很耗时的同步任务</span></span><br></pre></td></tr></table></figure><p>上面的代码中，异步任务不是 2 秒之后执行，而是等耗时的同步任务执行完毕之后，才执行。那这个异步任务，是在 5 秒后执行？还是在 7 秒后执行？这个作业，留给读者你来思考~</p><h3 id="举例-3（较真系列）"><a href="#举例-3（较真系列）" class="headerlink" title="举例 3（较真系列）"></a>举例 3（较真系列）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;异步任务&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>上面的代码中，等到 1 秒之后，真的会执行异步任务吗？其实不是。</p><p>在浏览器中， setTimeout()&#x2F; setInterval() 的每调用一次定时器的最小时间间隔是<strong>4 毫秒</strong>，这通常是由于函数嵌套导致（嵌套层级达到一定深度），或者是由于已经执行的 setInterval 的回调函数阻塞导致的。</p><p>上面的案例中，异步任务需要等待 1004 毫秒之后，才会从 Event Table 进入到 Event Queue。这在面试中也经常被问到。</p><h2 id="异步任务举例"><a href="#异步任务举例" class="headerlink" title="异步任务举例"></a>异步任务举例</h2><h3 id="例-1：加载图片"><a href="#例-1：加载图片" class="headerlink" title="例 1：加载图片"></a>例 1：加载图片</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载图片的异步任务</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">loadImage</span>(<span class="params">file, success, fail</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>()</span><br><span class="line">  img.<span class="property">src</span> = file</span><br><span class="line">  img.<span class="property">onload</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 图片加载成功</span></span><br><span class="line">    <span class="title function_">success</span>(img)</span><br><span class="line">  &#125;</span><br><span class="line">  img.<span class="property">onerror</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 图片加载失败</span></span><br><span class="line">    <span class="title function_">fail</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;img load fail&#x27;</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">loadImage</span>(</span><br><span class="line">  <span class="string">&#x27;images/qia nguyihao.png&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="params">img</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;图片加载成功&#x27;</span>)</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(img)</span><br><span class="line">    img.<span class="property">style</span>.<span class="property">border</span> = <span class="string">&#x27;solid 2px red&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;图片加载失败&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="例-2：定时器计时，移动-DOM-元素"><a href="#例-2：定时器计时，移动-DOM-元素" class="headerlink" title="例 2：定时器计时，移动 DOM 元素"></a>例 2：定时器计时，移动 DOM 元素</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数封装：定义一个定时器，每间隔 delay 毫秒之后，执行 callback 函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myInterval</span>(<span class="params">callback, delay = <span class="number">100</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timeId = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> <span class="title function_">callback</span>(timeId), delay)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">myInterval</span>(<span class="function"><span class="params">timeId</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 每间隔 500毫秒之后，向右移动 .box 元素</span></span><br><span class="line">  <span class="keyword">const</span> myBox = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;box&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">const</span> left = <span class="built_in">parseInt</span>(<span class="variable language_">window</span>.<span class="title function_">getComputedStyle</span>(myBox).<span class="property">left</span>)</span><br><span class="line">  myBox.<span class="property">style</span>.<span class="property">left</span> = left + <span class="number">20</span> + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">  <span class="keyword">if</span> (left &gt; <span class="number">300</span>) &#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(timeId)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每间隔 10 毫秒之后，将 .box 元素的宽度逐渐缩小，直到消失</span></span><br><span class="line">    <span class="title function_">myInterval</span>(<span class="function"><span class="params">timeId2</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> width = <span class="built_in">parseInt</span>(<span class="variable language_">window</span>.<span class="title function_">getComputedStyle</span>(myBox).<span class="property">width</span>)</span><br><span class="line">      myBox.<span class="property">style</span>.<span class="property">width</span> = width - <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">      <span class="keyword">if</span> (width &lt;= <span class="number">0</span>) <span class="built_in">clearInterval</span>(timeId2)</span><br><span class="line">    &#125;, <span class="number">10</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="number">200</span>)</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://github.com/PleaseStartYourPerformance/javaScript/issues/34">JS-同步任务，异步任务，微任务，和宏任务</a></li><li><a href="https://juejin.cn/post/6875605533127081992">JS 同步异步宏任务微任务</a>、<a href="https://zhuanlan.zhihu.com/p/364475433">JavaScript 中事件循环的理解</a>、<a href="https://github.com/reng99/blogs/issues/34">javascript 事件循环机制</a></li><li><a href="https://mp.weixin.qq.com/s/NqzWkeOhqAU85XPkJu_wCA">如何实现比 setTimeout 快 80 倍的定时器？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> js中的任务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js同步与异步任务 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
